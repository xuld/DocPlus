

        /// <summary>
        /// 添加要解析的文件夹。
        /// </summary>
        /// <param name="path">目标位置。</param>
        /// <returns>已成功添加的文件数。</returns>
        int AddDirectroy(string path);

        /// <summary>
        /// 批量添加要解析的文件。
        /// </summary>
        /// <param name="path">目标位置。</param>
        /// <returns>已成功添加的文件数。</returns>
        int AddFile(string path);

        /// <summary>
        /// 添加要解析的文件。
        /// </summary>
        /// <param name="path">目标文件的位置。</param>
        /// <returns>已成功添加的文件数。</returns>
        int AddFiles(IEnumerable<string> path);



		

        /// <summary>
        /// 批量添加要解析的文件。
        /// </summary>
        /// <param name="path">目标位置。</param>
        /// <returns>已成功添加的文件数。</returns>
        public virtual int AddFile(string path) {
            if(!Items.Contains(path))
                Items.Add(path);
            return 1;
        }

        /// <summary>
        /// 添加要解析的文件。
        /// </summary>
        /// <param name="path">目标文件的位置。</param>
        /// <returns>已成功添加的文件数。</returns>
        public virtual int AddFiles(IEnumerable<string> path) {
            int num = 0;
            foreach(string s in path) {
                num += AddFile(s);
            }

            return num;
        }

        /// <summary>
        /// 添加要解析的文件夹。
        /// </summary>
        /// <param name="path">目标位置。</param>
        /// <returns>已成功添加的文件数。</returns>
        public virtual int AddDirectroy(string path) {

            int num = 0;
            foreach(string s in System.IO.Directory.GetFiles(path, "*" + DefaultExt, System.IO.SearchOption.AllDirectories)) {
                num = num + AddFile(s);
            }

            return num;
        }


		

        /// <summary>
        /// 获取当前的项目文件地址。
        /// </summary>
        string ProjectPath {
            get;
        }



		
		

        /// <summary>
        /// 获取当前的项目文件地址。
        /// </summary>
        /// <value></value>
        public string ProjectPath {
            get;
            private set;
        }



		

/// <summary>
/// 数据访问层。
/// </summary>
public static class DataAccess {

    public static int ExecuteNonQuery(string sql) {

        using(OleDbConnection conn = new OleDbConnection(ConnectionString)) {
            conn.Open();
            var command = conn.CreateCommand();
            command.CommandText = sql;
            return command.ExecuteNonQuery();
        }

    }

    public static object[] ExecuteArray(string sql) {

        using(OleDbConnection conn = new OleDbConnection(ConnectionString)) {
            conn.Open();
            var command = conn.CreateCommand();
            command.CommandText = sql;
            var reader = command.ExecuteReader();

            if(reader.Read()) {
                object[] r = new object[reader.FieldCount];
                reader.GetValues(r);

                return r;
            }
        }

        return null;
    }

}




using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel;

namespace DocPlus.Parser.Javascript {

    /// <summary>
    /// 表示文档解析时的配置。
    /// </summary>
    [Serializable]
    public class DocParseSettings {

        public DocParseSettings() {
            EnableAutoCreateComment = CheckIdentifierStart = EnableGlobalNamespace = UseNamingRules = AutoCreateParamComment = AutoCreateFunctionParam = true;


            NewLine = Environment.NewLine;

        }

        /// <summary>
        /// 获取或设置是否忽略语法错误。
        /// </summary>
        [Category("语法")]
        [Description("在解析语法时出现错误时，是否继续生成文档。")]
        [DefaultValue(false)]
        [DisplayName("跳过语法错误")]
        public bool SkipSyntaxError {
            get;
            set;
        }

        /// <summary>
        /// 获取或设置是否启用严格模式。(在 Javascript 中，使用首句 "use strict" 同样可启用)
        /// </summary>
        [Category("语法")]
        [Description("是否启用严格模式。(在 Javascript 中，使用首句 \"use strict\" 同样可启用)")]
        [DefaultValue(false)]
        [DisplayName("检查严格模式")]
        public bool IsStrictMode {
            get;
            set;
        }

        /// <summary>
        /// 获取或设置是否启用自动生成注释。
        /// </summary>
        [Category("注释")]
        [Description("在为一个无文档注释的变量赋值时，是否需要使用值的注释作为此变量的注释。")]
        [DefaultValue(true)]
        [DisplayName("自动生成注释")]
        public bool EnableAutoCreateComment { get; set; }

        /// <summary>
        /// 获取或设置是否自动把类普通成员标记成 static 。
        /// </summary>
        [Category("注释")]
        [Description("如果此项为 false，且类的成员没有标记 @static ， 那么这个成员会被作为非静态成员处理。")]
        [DefaultValue(false)]
        [DisplayName("识别静态")]
        public bool EnableAutoCreateStatic { get; set; }

        /// <summary>
        /// 获取或设置是否启用全局名字空间模式。
        /// </summary>
        [Category("注释")]
        [Description("是否根据上下文的标签分析变量的所在成员。如上文存在 @class ，则下文中的所有变量都解析为 @class 的成员。")]
        [DefaultValue(true)]
        [DisplayName("名字空间模式")]
        public bool EnableGlobalNamespace { get; set; }

        /// <summary>
        /// 获取或设置是否自动识别命名规则。(如 _ 开头的变量自动识别成私有成员)
        /// </summary>
        [Category("注释")]
        [Description("是否需自动识别命名规则。如 _ 开头的变量自动识别成私有成员。")]
        [DefaultValue(true)]
        [DisplayName("识别命名规则")]
        public bool UseNamingRules { get; set; }

        /// <summary>
        /// 获取或设置是否把标记为 internal 的成员作为普通成员解析。
        /// </summary>
        [Category("文档")]
        [Description("是否把标记为 @internal 的成员作为普通成员解析。")]
        [DefaultValue(false)]
        [DisplayName("处理内部变量")]
        public bool EnableInternal { get; set; }

        /// <summary>
        /// 获取或设置是否解析全部对象。(肯能导致解析很多垃圾成员)
        /// </summary>
        [Category("文档")]
        [Description("是否解析全部对象，即使这些对象不带注释。(肯能导致解析很多垃圾成员)")]
        [DefaultValue(false)]
        [DisplayName("解析全部对象")]
        public bool ResolveUncommentedValue { get; set; }

        /// <summary>
        /// 获取或设置跟目录。
        /// </summary>
        [Category("文档")]
        [Description("生成文档中的文件位置将以相对此路径而记录。")]
        [DisplayName("跟目录")]
        [DefaultValue(null)]
        [Editor(typeof(System.Windows.Forms.Design.FolderNameEditor), typeof(System.Drawing.Design.UITypeEditor))]
        public string RootPath { get; set; }

        /// <summary>
        /// 使用兼容 jsdoc 的长久名字空间模式。
        /// </summary>
        [Category("文档")]
        [Description("如果启用作用域，名字空间的范围将只在当前作用域有效，否则使用兼容 jsdoc 的就近原则形式。")]
        [DisplayName("禁用作用域")]
        [DefaultValue(false)]
        public bool DisableNamespaceClear { get; set; }

        /// <summary>
        /// 自动根据参数名决定类型。
        /// </summary>
        [Category("文档")]
        [Description("根据参数名决定类型。如 isXXX 的类型为 Boolean")]
        [DisplayName("分析参数名")]
        [DefaultValue(true)]
        public bool AutoCreateParamComment { get; set; }

        /// <summary>
        /// 如果是静态类，自动标记全部成员都静态的。
        /// </summary>
        [Category("文档")]
        [Description("如果是静态类，自动标记全部成员为静态的。")]
        [DisplayName("处理静态类")]
        [DefaultValue(false)]
        public bool AutoMarkClassAttribute { get; set; }

        /// <summary>
        /// 当多行注释分行后，补充的字符。 默认是回车。
        /// </summary>
        [Category("注释")]
        [Description("在长注释中，原文出现换行后的处理方式。(默认为保留换行)")]
        [DisplayName("注释中的换行")]
        [DefaultValue("\r\n")]
        [Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
        public string NewLine { get; set; }

        /// <summary>
        /// 是否排除不符合ECMA命名规范的属性。
        /// </summary>
        [Category("文档")]
        [Description("是否排除不符合ECMA命名规范的属性。")]
        [DisplayName("过滤属性")]
        [DefaultValue(true)]
        public bool CheckIdentifierStart { get; set; }

        /// <summary>
        /// 是否自动生成函数的参数。
        /// </summary>
        [Category("文档")]
        [Description("是否根据函数定义自动生成 @param 标签。")]
        [DisplayName("参数")]
        [DefaultValue(true)]
        public bool AutoCreateFunctionParam { get; set; }
    }
}





        public DocParseSettings Settings {
            get {
                return new DocParseSettings() {
                    SkipSyntaxError = SkipSyntaxError,
                    IsStrictMode = _javascriptParser.IsStrictMode,
                    NewLine = _docCommentParser.NewLine,
                    AutoCreateParamComment = DocumentCommentParser.AutoCreateParamComment,
                    EnableAutoCreateComment = _docAstVistor.EnableAutoCreateComment,
                    EnableAutoCreateStatic = _docAstVistor.EnableAutoCreateStatic,
                    EnableGlobalNamespace = _docAstVistor.EnableGlobalNamespace,
                    DisableNamespaceClear = _docAstVistor.DisableNamespaceClear,
                    AutoCreateFunctionParam = DocAstVistor.AutoCreateFunctionParam,
                    AutoMarkClassAttribute = _docCreater.AutoMarkClassAttribute,
                    UseNamingRules = _docAstVistor.UseNamingRules,
                    CheckIdentifierStart = _docCreater.CheckIdentifierStart,
                    EnableInternal = _docCreater.EnableInternal,
                    ResolveUncommentedValue = _docCreater.ResolveUncommentedValue,
                    RootPath = RootPath
                };
            }
            set {
                SkipSyntaxError = value.SkipSyntaxError;
                _javascriptParser.IsStrictMode = value.IsStrictMode;
                _docCommentParser.NewLine = _docCommentParser.NewLine;
                DocumentCommentParser.AutoCreateParamComment = value.AutoCreateParamComment;
                _docAstVistor.EnableAutoCreateComment = value.EnableAutoCreateComment;
                _docAstVistor.EnableAutoCreateStatic = value.EnableAutoCreateStatic;
                _docAstVistor.EnableGlobalNamespace = value.EnableGlobalNamespace;
                _docAstVistor.DisableNamespaceClear = value.DisableNamespaceClear;
                _docAstVistor.UseNamingRules = value.UseNamingRules;
                DocAstVistor.AutoCreateFunctionParam = value.AutoCreateFunctionParam;
                _docCreater.EnableInternal = value.EnableInternal;
                _docCreater.ResolveUncommentedValue = value.ResolveUncommentedValue;
                _docCreater.AutoMarkClassAttribute = value.AutoMarkClassAttribute;
                _docCreater.CheckIdentifierStart = value.CheckIdentifierStart;



                RootPath = value.RootPath;
            }
        }

		

        #region 子变量

        Dictionary<string, Variant> _children;

        Dictionary<string, Variant> Children {
            get {
                if(_children == null) {
                    _children = new Dictionary<string, Variant>();
                }

                return _children;
            }
        }

        public void Add(string key, Variant value) {
            Children.Add(key, value);
        }

        public bool ContainsKey(string key) {
            return _children == null ? false : _children.ContainsKey(key);
        }

        public new ICollection<string> Keys {
            get {
                return Children.Keys;
            }
        }

        public bool Remove(string key) {
            if(_children != null)
                return _children.Remove(key);

            return false;
        }

        bool IDictionary<string, Variant>.TryGetValue(string key, out Variant value) {
            return Children.TryGetValue(key, out value);
        }

        public ICollection<Variant> Values {
            get {
                return Children.Values;
            }
        }

        /// <summary>
        /// 获取或设置当前变量内的子变量。
        /// </summary>
        /// <param name="name">变量名。</param>
        /// <returns>变量实例。</returns>
        public Variant this[string key] {
            get {
                if(_children == null)
                    return null;

                Variant t;
                return _children.TryGetValue(key, out t) ? t : null;
            }
            set {
                Children[key] = value;
            }
        }

        void IDictionary<string, Variant>.Add(KeyValuePair<string, Variant> item) {
            ((IDictionary<string, Variant>)Children).Add(item);
        }

        public void Clear() {
            if(_children != null) {
                _children.Clear();
            }
        }

        bool IDictionary<string, Variant>.Contains(KeyValuePair<string, Variant> item) {
            return ((IDictionary<string, Variant>)Children).Contains(item);
        }

        void IDictionary<string, Variant>.CopyTo(KeyValuePair<string, Variant>[] array, int arrayIndex) {
            ((IDictionary<string, Variant>)Children).CopyTo(array, arrayIndex);
        }

        bool IDictionary<string, Variant>.IsReadOnly {
            get {
                return ((IDictionary<string, Variant>)Children).IsReadOnly;
            }
        }

        bool IDictionary<string, Variant>.Remove(KeyValuePair<string, Variant> item) {
            return ((IDictionary<string, Variant>)Children).Remove(item);
        }

        public new IEnumerator<KeyValuePair<string, Variant>> GetEnumerator() {
            return Children.GetEnumerator();
        }

        public new int Count {
            get {
                return _children == null ? 0 : _children.Count;
            }
        }

        #endregion